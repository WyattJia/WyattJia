* Redis 五大常用数据结构

  * sorted-set 多了权重的 set ，使 set 有序
  * hash value 存放结构化对象，就是字典 
  * string 常用的 set/get 操作，value 可以是 string 也可以是数字
  * list 简单的队列
  * set 不重复值的几个

* rdb 和 aof


* 为什么使用 redis

  * 性能
    耗时久，变动不频繁的 SQL 
  * 并发
    大并发的情况下避免直接请求数据库，redis 作为中间件做缓冲操作。

* Redis 缺点，以及如何避免？

  * 缓存和数据库的双写一致问题
  * 缓存雪崩问题
  * 缓存击穿问题
  * 缓存的并发竞争问题

* 为什么这么快
  * 纯内存
  * 单线程
  * epoll

* 过期策略和内存淘汰
  过期策略：定期删除 + 过期删除
  * 定期删除，每隔 100ms 随机抽样检查 key ，过期就删除，
  * 惰性删除，获取 key 的时候检查是否过期，过期的话就删除了。
  内存淘汰机制
  ```conf
  # redis.conf
  # maxmemory-policy volatile-lru # 这样用来配置内存淘汰机制。
  ```
  共有 6 个选项:
  * noevicition 内存不足写入时会报错，少用
  * allkeys-lru 内存不足时，移除最近最少使用的 key ，推荐用
  * allkeys-random 内存不足时，随意移除某个 key ，不安全，少用
  * volatile-lru 内存不足时，在设置过期时间的键中移除最近最少使用的keu ，不推荐
  * volatile-random 内存不足时，在设了过期时间的 key 中随机移除 key ，不安全
  * volatile-ttl 内存不足的时候，在设了过期时间的key 中，有限删除更早过期时间的 key ，不推荐。


* Redis 和 数据库双写一致性问题
  分最终一致性和强一致性。
  如果对数据有强一致性要求，不能放缓存。我们只能尽力保证最终一致性，降低不一致性发生的概率。
  做法: 1.采取正确的更新策略；2.先更新数据库，在删除缓存；3.如果删除缓存失败，加个补偿措施，用消息队列。

* 缓存穿透和缓存雪崩问题

  * 缓存穿透，请求缓存中不存在的数据，导致请求直接连到数据库，导致数据库异常
  解决方法: 
    1. 互斥锁，缓存失败了，先获得锁，在请求数据库，没得到所就再休眠一段时间。
    2. 异步更新，无论有没有拿到 key ，都直接返回调用，然后去获取缓存，如果没有缓存就另起一个线程去获取缓存。需要预热缓存。
    3. 提供一个能够迅速判断请求是否有效的拦截机制，如布隆过滤器，判断 key 是否有效，无效则直接返回。
  * 缓存雪崩，缓存在同一时间大面积失效。
    解决方法:
    1. 给缓存失效时间加个随机值
    2. 使用互斥锁，性能会降低
    3. 双缓存

* 并发竞争 Key 问题
  1. 如果 key 操作不要求顺序，则准备一个分布式锁，抢到锁再用 key
  2. 如果对 key 操作要求顺序执行，给 value 保存一个时间戳，写入的时候对比时间戳就可以了。
  3. 用队列，串行 set key 

* 使用 Redis 的好处

  1. 速度快，数据读取类似 hash 大O是常数，也有 skiplist 实现的数据结构，但也很快很稳。
  2. 数据结构多
  3. 有事务，操作都是原子性，但不是真正地事务。
  4. 玩法多样，可用于缓存，消息队列等



