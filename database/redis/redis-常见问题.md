* Redis 五大常用数据结构

  * sorted-set 多了权重的 set ，使 set 有序
  * hash value 存放结构化对象，就是字典 
  * string 常用的 set/get 操作，value 可以是 string 也可以是数字
  * list 简单的队列
  * set 不重复值的几个

* rdb 和 aof


* 为什么使用 redis

  * 性能
    耗时久，变动不频繁的 SQL 
  * 并发
    大并发的情况下避免直接请求数据库，redis 作为中间件做缓冲操作。

* Redis 缺点，以及如何避免？

  * 缓存和数据库的双写一致问题
  * 缓存雪崩问题
  * 缓存击穿问题
  * 缓存的并发竞争问题

* 为什么这么快
  * 纯内存
  * 单线程
  * epoll

* 过期策略和内存淘汰
  过期策略：定期删除 + 过期删除
  * 定期删除，每隔 100ms 随机抽样检查 key ，过期就删除，
  * 惰性删除，获取 key 的时候检查是否过期，过期的话就删除了。
  内存淘汰机制
  ```conf
  # redis.conf
  # maxmemory-policy volatile-lru # 这样用来配置内存淘汰机制。
  ```
  共有 6 个选项:
  * noevicition 内存不足写入时会报错，少用
  * allkeys-lru 内存不足时，移除最近最少使用的 key ，推荐用
  * allkeys-random 内存不足时，随意移除某个 key ，不安全，少用
  * volatile-lru 内存不足时，在设置过期时间的键中移除最近最少使用的keu ，不推荐
  * volatile-random 内存不足时，在设了过期时间的 key 中随机移除 key ，不安全
  * volatile-ttl 内存不足的时候，在设了过期时间的key 中，有限删除更早过期时间的 key ，不推荐。


* Redis 和 数据库双写一致性问题
  分最终一致性和强一致性。
  如果对数据有强一致性要求，不能放缓存。我们只能尽力保证最终一致性，降低不一致性发生的概率。
  做法: 1.采取正确的更新策略；2.先更新数据库，在删除缓存；3.如果删除缓存失败，加个补偿措施，用消息队列。

* 缓存穿透和缓存雪崩问题

  * 缓存穿透，请求缓存中不存在的数据，导致请求直接连到数据库，导致数据库异常
  解决方法: 
    1. 互斥锁，缓存失败了，先获得锁，在请求数据库，没得到所就再休眠一段时间。
    2. 异步更新，无论有没有拿到 key ，都直接返回调用，然后去获取缓存，如果没有缓存就另起一个线程去获取缓存。需要预热缓存。
    3. 提供一个能够迅速判断请求是否有效的拦截机制，如布隆过滤器，判断 key 是否有效，无效则直接返回。
  * 缓存雪崩，缓存在同一时间大面积失效。
    解决方法:
    1. 给缓存失效时间加个随机值
    2. 使用互斥锁，性能会降低
    3. 双缓存

* 并发竞争 Key 问题
  1. 如果 key 操作不要求顺序，则准备一个分布式锁，抢到锁再用 key
  2. 如果对 key 操作要求顺序执行，给 value 保存一个时间戳，写入的时候对比时间戳就可以了。
  3. 用队列，串行 set key 

* 使用 Redis 的好处

  1. 速度快，数据读取类似 hash 大O是常数，也有 skiplist 实现的数据结构，但也很快很稳。
  2. 数据结构多
  3. 有事务，操作都是原子性，但不是真正地事务。
  4. 玩法多样，可用于缓存，消息队列等

* 性能问题和解决方法:
  1. Master 写内存快照，save 命令调用 rdbSave 函数，会阻塞主线程，master 最好不要写内存快照。
  2. aof 持久化 master 最好不要做持久化工作，包括全量内存快照和 aof ，特别是内存快照。
  3. 重写 aof 文件的时候，会占用大量的 cpu 和内存资源，会短暂暂停服务
  4. 主从复制的 slave 和 master 最好在同一个虚拟网络里面。


* MySQL 里面有 2000w 数据，redis 中有 20w 数据，如何保证redis 中的数据都是热点数据
  用内存淘汰策略

* 事务，cas

  MULTI EXEC DISCARD WATCH 实现事务

  事务特征:
  1. 事务中所有的命令会被串行化顺序执行，并赞同对其他客户端服务。
  2. 事务中某条命令失败，其他命令依然会执行
  3. multi 开启事务，类似于 sql 中的begin TRANSACTION，用 exec/discard 提交或者回滚事务内的操作，类似于 sql 中的commit 和 rollback
  4. append-only 模式遇断电等故障不会有原子性。利用 redis-check-aof 工具可以回滚数据。

* Watch 基于 cas 的乐观锁

  watch 命令有 check-and-set cas 的功能，check key 之后在 set exec 提交。

* Redis 持久化

  1. 快照
    默认情况下，存在 dump.rdb 。fork 子进程，子进程写数据到 rdb ，写完之后用新文件替换旧文件，copy and write 。
  2. aof 非全量

* 主键失效

  给key 设置过期时间

* 读写分离模型

   增加 Slave DB 的数量，读性能会线性增长。通常采用双 Master DB 热备，排除单 Master 故障的问题。缺点在于扩展能力受限于单点存储能力，写入性能不会线性成长。

* 数据分片模型

  为了解决分离模型缺陷的产物，将每个节点看成独立的 Master ，通过业务实现数据分片。水平分片，一个 master 节点设计成 Master + 多个 Slave 的模型。

* 分布式锁

  先拿 setnx 争抢锁，抢到之后，用 expire 给锁加过期时间，防止锁忘记释放。

* 如果锁在 setnx 抢到之后，expire 加锁过期时间之前进程崩溃了怎么办

  redis 2.6 之后可以在 set 的时候加上一系列参数是 set 和 expire 合并成一条指令来操作，这条指令有原子性。

* 线上服务要用 keys 指令怎么办

  不要用 keys ，用 scan 取代，scan 可以无阻塞取出 key 列表，但需去重。

* redis 作为异步队列

  list 结构作为队列，rpush 生产消息，lpop 消费消息，blpop 等到有消息再消费。延时队列用 sorted set ，时间戳作为权重即可。

* 大量 Key 同时过期怎么办

  给 key 将随机时间就不会同时过期了。

* 持久化

  一般两者会同时搭配使用

  * bgsave 做全量持久化

  bgsave 原理：子进程 fork 出来进行 copy and write 。

  * aof 做增量持久化

  突然停电怎么办，aof 每个几秒可定时 sync 。

* 同步机制

  主从同步，从从同步。第一次同步的时候，主节点做一次 bgsave ，之后同时将后续操作记录到内存，完成后将 rdb 全量同步到复制节点，复制节点接受之后，将 rdb 加载到内存中，再通知主节点即可。

* Redis 集群

  * Redis sentinal 重点在高可用，类似选举机制

  * Redis Cluster 重点在于扩展性，单个 redis 用 Cluster 分片存储。

* Redis IO 控制

   pipeline

* 如何多机 Redis 部署，如何保证数据一致。

  主从复制，读写分离。复制功能就是多个数据库之间的数据同步。
    1. 数据库启动的时候，向主数据库发送 sync 命令。
    2. 主数据库接受 sync 的时候开始在后台保存快照，并将保存期间受到的命令缓存下来。
    3. 快照完成之后，将快照和缓存命令发送给从数据库。
    4. 从数据库开始载入快照并执行缓存命令。
    5. 我们把数存到redis的一个节点，在另一个节点却能查询到，这是怎么实现的呢,用主从复制
    6. 强一致性和最终一致性
       * 强一致性，任何时候所有节点的数据是一样的

       * 弱一致性，就是最终一致性，不保证任何时刻所有节点的数据都是一样的，但是能保证随着时间迁移，不同节点上的同一份数据总是在趋同。

* 两个文件上一个 URL 怎么找重复的

  A、B 两个文件，各存放 50 亿个URL，每个 URL 占用 64 bit ，内存限制 4G ,找出 A、B 文件中相同的 URL 。

  方法: 1. bloom filter
        2. hash(url)%k, k 表示切分后的文件数，就是哈希一致性算法。然后隔壁小文件对比就行了。


