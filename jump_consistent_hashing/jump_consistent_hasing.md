### 前言 
跳跃式哈希一致性是 Google 提出的一个新式的一致性哈希算法。
有别于传统环形一致性哈希，跳跃式一致性哈希的空间复杂度更低，而且无内存占用，算法实现过程也十分简洁。

### 算法概述

一致性哈希的主要目的，节点数量变更的时候，只需要在节点间变化少量数据，而不需要全量变更数据，这样使得节点扩容或者缩容能够更加弹性，不至于影响全部数据。
传统的一致性哈希实现方法通常是哈希环+取模，相比之下，跳跃式一致性哈希在执行速度、内存消耗、均匀分布性上都比哈希环算法要好。

* 首先我们假设只有一个节点，所有的数据当然也都在这一个节点里面，用代码表示的话，也就是`consistent_hash(key, 1) = 1` 。
* 然后我们考虑增加一个节点，这个总共有了两个节点，节点增加完成之后，我们随机抽取一号节点 1/2 的数据到二号节点中去。
* 然后再加一个节点，然后需要从一号，二号节点中，各自取出 1/6 ，总共 1/3 的数据移动到三号节点。这样一号二号节点中的 key ，每个 key 都有 1/3 的几率被抽中。

你有没有发现，每增加一个节点，只需要移动 1/n 的数据，而不需要移动几乎所以有数据。

接上面第三点的过程，扩缩容的时候，我们需要在老数据中随机抽取数据，这里的随机抽取不能是真随机的随机，而应该是用 key 为随机数种子，使得随机过程可重现，让每个 key 首次放入和后续取回使用的都是相同的随机数序列。

根据上面的规律，我们简单归纳一下 key 在不同节点时的大致规律：
* 只有一个节点，只能在一号节点
* 有 n 个节点， 增加一个节点到 n + 1 个。key 目前所在的位置由之前的 `consistent_hash(key, n)` 情况来确定。总体上一个 key 会有 1/(n + 1) 的概率被移动到 n + 1 号节点。
  即 n+1 节点时，key 所在的位置由 n 节点时的位置和一个随机变量 rand 决定, 如果 rand<1/(n+1)，它就会跳跃到 n+1 节点，否则则和 n 节点时一样。

### 代码实现
```go
package main

import (
	"math/rand"
)

/*
开始桶的总数为1，所有的key都放在第0个桶中。
然后每增加一个桶，生成一个随机数，
当这个随机数为奇数时，将key放在保持在原始桶中，
当这个key为偶数时，将key移动到新增的桶中。
*/
func consistentHashOne(key int, n int) int {
	/* 使用 key 作为随机数的种子，
       一旦 key 和 n 确定了，
	函数的返回值也是固定的，
	并且当函数参数为 n 和参数为 n - 1 时，
	循环过程中的前面几步生成的随机数都是一样的。
	*/
	rand.Seed(int64(key))
	id := 0
	for i := 1; i < n; i ++ {
		// 每增加一个桶，生成一个随机数
		if rand.Uint64() % 2 == 1 {
			// 如果随机数是奇数，key 保留在原来的桶中
			id = id
		} else {
			// 如果随机数是偶数，key 移动到新分配的桶中
			id = i
		}
	}
	return id
}


/*
开始桶的总数为1，所有的key都放在第0个桶中，
同时生成一个大于当前桶数的随机数。
每增加一个新桶时，判断当前桶总数是否超过这个随机数。
如果未超过（桶数小于或等于这个随机数），则将key保留在原来的桶中；
如超过，则将key移动到新增加的桶中，同时重新生成一个大于当前桶数的随机数，
后续增加新桶时，使用和前面相同的逻辑进行判断。
*/
func consistentHashTwo(key int, n int) int {
    rand.Seed(int64(key))
    id := 0
    // 生成一个随机数 fence
    fence := rand.Int()
    for n > fence {
    	id = fence
    	fence = id + rand.Int()
	}
	return id
}
```

### Reference
[A Fast, Minimal Memory, Consistent Hash Algorithm](https://arxiv.org/pdf/1406.2294)
