
## 数据库变动/迁徙时需要注意的一些事

### The good

**能够在迁移数据库时安全操作数据库而不会导致宕机的操作。**

| 能够做的 |
| ----------- |
| 新增一个 column |
| 删除一个 column |
| concurrently 地增加一个索引 |
| 删除一个约束 (例如, 非可空选项) |
| 给现存的 column 增加一个默认值 |

---
---

### The bad

**不可取的一些办法，以及变通方法。**

| 不能在一个大 table 下做的操作         |    解决方法     |
| ------------------------------------- | :-------------: |
| 增加一个索引                          |  增加索引的时候加 CONCURRENTLY 关键词 | 
| 改变一个 column 的类型                |  新增一个新的 column, 更改代码以同时写入两个 column，然后将新的 column 回填至与旧 column 一样的量级。|
| 增加一个 column 的默认值              |  新增一个 column , 在一个分开的命令里设置默认值，然后将默认值填到 column 。 |
| 增加一个非空的 column                 |  新增一张带了非可空 column 的 table，同时写入两张 table ，逐渐将旧表数据回填到新表，然后切换到新表。[1] |
| 给一个 column 增加唯一约束            |  新增 column, concurrently 地添加唯一索引约束,然后给表增加约束。 [2] |
| 用 VACUUM FULL 清空磁盘工具 [3]           |  也可以使用 pg\_repack 代替 |


* [1] 

  解决方案较为繁琐，一般不太经常使用。建议在新键表的时候仔细点，搞清楚哪些字段需要设置成非空。

* [2] 
  ``` sql
  CREATE UNIQUE INDEX CONCURRENTLY token_is_unique ON large_table(token); 
  ALTER TABLE large_table ADD CONSTRAINT token UNIQUE USING INDEX token_is_unique;
  ```

* [3]
  删除一个 column 很快，但是 pg 并不会马上就从磁盘清除空间，除非调用 `VACUUM FULL` 命令，或者使用第三方工具 `pg_repack` 替代。


---
---

## SQL 优化总结

### 合理设计

* 代码和数据库模型是否设计合理
* 需要用索引的地方是否加了索引，是否用对了索引
* 使用缓存是否能减少不必要的重复查询

### 索引以及索引优化步骤（代价低到高）

  1. 使用 explain 检查查询语句的索引使用情况，尽量将索引优化成`三星索引`。
     注意事项：
       * 连表时，表的编码是否相同，不同则不上索引
       * 索引类型是否正确
       * 能否命中数据库缓存
       * 三星索引，所有查询的字段，where 从句的字段，order by 的字段三个字段都带有索引，则是三星索引。

  2. 升级数据库配置
     * 升级内存
     * 换 CPU 
     * 换 SSD
     * 组合以上方案

  3. 读写分离，一写多读

  4. 垂直分表。将一个大的表中的 n 个列重新组合，把不必要的表拆分出去，组成新的表。可以减少每次所需要传输的数据量，减少 I/O 。

  5. 水平分表。将表按照某个维度切割成多个表。如时间维度，比如说某些表只需要存近三个月的数据，那么可以吧三个月之前的表插入到另外的表中。这样做可以减少表的行数，降低 B 树的深度和子节点数量，减少数据量，减少 I/O ，提高查询速度。

  6. 垂直分库。微服务中，不同的服务使用不同的数据库就是垂直分库的作用，可以吧不同的瓶颈分散到不同的数据库中。

  7. 水平分库。即 sharding ，按照某个维度，将数据存储到多个不同的库里面。
     > mongodb object id 作为全局唯一标识符


---
---

## 看懂 PostgreSQL 的 explain 输出

